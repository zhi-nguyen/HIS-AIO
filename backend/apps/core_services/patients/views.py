from rest_framework import viewsets, filters, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django_filters.rest_framework import DjangoFilterBackend
from .models import Patient
from .serializers import PatientSerializer

import uuid

class PatientViewSet(viewsets.ModelViewSet):
    queryset = Patient.objects.all().order_by('-created_at')
    serializer_class = PatientSerializer
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['patient_code', 'id_card', 'first_name', 'last_name', 'contact_number', 'insurance_number']
    filterset_fields = ['gender', 'province', 'ward']

    def perform_create(self, serializer):
        # Auto-generate patient_code if needed, though most likely generated by Signal/Model
        # For now, let's assume manual or auto-gen by model logic.
        # But looking at model, it has no auto-gen. Let's create a simple one.
        if not serializer.validated_data.get('patient_code'):
             # Simplistic generator: P + timestamp prefix or UUID suffix
             # Real world: Sequence table.
             code = f"P{uuid.uuid4().hex[:8].upper()}"
             serializer.save(patient_code=code)
        else:
             serializer.save()

    @action(detail=False, methods=['get'])
    def lookup(self, request):
        """
        Quick lookup by ID Card or Phone or Insurance
        Usage: /api/v1/patients/lookup/?q=...
        """
        q = request.query_params.get('q')
        if not q:
            return Response({"error": "Query parameter 'q' is required"}, status=status.HTTP_400_BAD_REQUEST)
        
        patients = Patient.objects.filter(
            id_card=q
        ) | Patient.objects.filter(
            contact_number=q
        ) | Patient.objects.filter(
            insurance_number=q
        )
        
        serializer = self.get_serializer(patients, many=True)
        return Response(serializer.data)

